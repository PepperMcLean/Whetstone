Intro to Big O
  Objectives
    Motivate the need for something like Big O Notation
    Describe what Big O Notation is
    Simplify Big O expressions
  
  Whats the idea here?
    Imagine we have multiple implementations of the same function.
    How can we determine which one is the "best?"
    
  Who cares?
    It's important to have a precise vocabulart to talk about how our code performs
    Useful for discussing trade-offs between different approaches
    When your code slows down or crashes, identifying parts of the code that are inefficient can help us find pain points in our applications
    Less important: it comes up in interviews!

Timing Our code
  An Example (ex.1)
    Suppose we want to write a function that calculates the sum of all numbers from 1 up to (and including) some number n.
  
  What does better mean?
    Faster?
    Less memory-intensive?
    More readable?
    Brevity?
    Frequently the first two are more important than the others
  
  Why not use timers? (ex.1)
  
  The Problem with time
    Different machines will record different times
    The same machine will record different times!
    For fast algorithms, speed measurements may not be precise enough?

  If not time, then what?
    Rather than counting seconds, which are so variable...
    Let's count the number of simple operations the computer has to perform!
      In ex.1 
        V2 has 3 operations
        V1 has (5n + 2) operations
        In V1 regardless of the exact number, the number of operations grows roughly proprtionally with n.

Official Intro to Big O
  Introducing... Big O
    Big O Notation is a way to formalize fuzzy counting
    It allows us to talk formally about how the runtime of an algorithm grows as the inputs grow
    We won't care about the details, only the trends
  Big O Definition
    We say that an algorithm is O(f(n)) if the number of simple operations the computer has to do is 
      eventually less than a constant times f(n), as n increases
    f(n) could be linear (f(n) = n) // O(n)
    f(n) could be quadratic (f(n) = n^2) // O(n^2)
    f(n) could be constant (f(n) = 1) // O(1)
    F(n) could be something entirely different!
